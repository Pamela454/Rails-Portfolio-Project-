module Net
  class Protocol
    VERSION: String
  end

  class ProtocolError < StandardError
  end

  class ProtoSyntaxError < ProtocolError
  end

  class ProtoFatalError < ProtocolError
  end

  class ProtoUnknownError < ProtocolError
  end

  class ProtoServerError < ProtocolError
  end

  class ProtoAuthError < ProtocolError
  end

  class ProtoCommandError < ProtocolError
  end

  class ProtoRetriableError < ProtocolError
  end

  class HTTPBadResponse < StandardError
  end

  class HTTPHeaderSyntaxError < StandardError
  end

  # <!-- rdoc-file=lib/net/protocol.rb -->
  # OpenTimeout, a subclass of Timeout::Error, is raised if a connection cannot be
  # created within the open_timeout.
  #
  class OpenTimeout < Timeout::Error
  end

  # <!-- rdoc-file=lib/net/protocol.rb -->
  # ReadTimeout, a subclass of Timeout::Error, is raised if a chunk of the
  # response cannot be read within the read_timeout.
  #
  class ReadTimeout < Timeout::Error
  end

  # <!-- rdoc-file=lib/net/protocol.rb -->
  # WriteTimeout, a subclass of Timeout::Error, is raised if a chunk of the
  # response cannot be written within the write_timeout.  Not raised on Windows.
  #
  class WriteTimeout < Timeout::Error
  end

  # <!-- rdoc-file=lib/net/http.rb -->
  # Class Net::HTTP provides a rich library that implements the client in a
  # client-server model that uses the HTTP request-response protocol. For
  # information about HTTP, see
  #
  # *   [Hypertext Transfer
  #     Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  # *   [Technical
  #     overview](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Techni
  #     cal_overview).
  #
  #
  # Note: If you are performing only a few GET requests, consider using
  # [OpenURI](rdoc-ref:OpenURI); otherwise, read on.
  #
  # ## Synopsis
  #
  # If you are already familiar with HTTP, this synopsis may be helpful.
  #
  # [Session](rdoc-ref:Net::HTTP@Sessions) with multiple requests for [HTTP
  # methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_met
  # hods):
  #
  #     Net::HTTP.start(hostname) do |http|
  #       # Session started automatically before block execution.
  #       http.get(path_or_uri, headers = {})
  #       http.head(path_or_uri, headers = {})
  #       http.post(path_or_uri, data, headers = {})  # Can also have a block.
  #       http.put(path_or_uri, data, headers = {})
  #       http.delete(path_or_uri, headers = {Depth: 'Infinity'})
  #       http.options(path_or_uri, headers = {})
  #       http.trace(path_or_uri, headers = {})
  #       http.patch(path_or_uri, data, headers = {}) # Can also have a block.
  #       # Session finished automatically at block exit.
  #     end
  #
  # [Session](rdoc-ref:Net::HTTP@Sessions) with multiple requests for [WebDAV
  # methods](https://en.wikipedia.org/wiki/WebDAV#Implementation):
  #
  #     Net::HTTP.start(hostname) do |http|
  #       # Session started automatically before block execution.
  #       http.copy(path_or_uri, headers = {})
  #       http.lock(path_or_uri, body, headers = {})
  #       http.mkcol(path_or_uri, body = nil, headers = {})
  #       http.move(path_or_uri, headers = {})
  #       http.propfind(path_or_uri, body = nil, headers = {'Depth' => '0'})
  #       http.proppatch(path_or_uri, body, headers = {})
  #       http.unlock(path_or_uri, body, headers = {})
  #       # Session finished automatically at block exit.
  #     end
  #
  # Each of the following methods automatically starts and finishes a
  # [session](rdoc-ref:Net::HTTP@Sessions) that sends a single request:
  #
  #     # Return string response body.
  #     Net::HTTP.get(hostname, path, port = 80)
  #     Net::HTTP.get(uri, headers = {}, port = 80)
  #
  #     # Write string response body to $stdout.
  #     Net::HTTP.get_print(hostname, path_or_uri, port = 80)
  #     Net::HTTP.get_print(uri, headers = {}, port = 80)
  #
  #     # Return response as Net::HTTPResponse object.
  #     Net::HTTP.get_response(hostname, path_or_uri, port = 80)
  #     Net::HTTP.get_response(uri, headers = {}, port = 80)
  #
  #     Net::HTTP.post(uri, data, headers = {})
  #     Net::HTTP.post_form(uri, params)
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## URIs
  #
  # On the internet, a URI ([Universal Resource
  # Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)) is a
  # string that identifies a particular resource. It consists of some or all of:
  # scheme, hostname, path, query, and fragment; see [URI
  # syntax](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax).
  #
  # A Ruby [URI::Generic](rdoc-ref:URI::Generic) object represents an internet
  # URI. It provides, among others, methods `scheme`, `hostname`, `path`, `query`,
  # and `fragment`.
  #
  # ### Schemes
  #
  # An internet URI has a
  # [scheme](https://en.wikipedia.org/wiki/List_of_URI_schemes).
  #
  # The two schemes supported in Net::HTTP are `'https'` and `'http'`:
  #
  #     uri.scheme                       # => "https"
  #     URI('http://example.com').scheme # => "http"
  #
  # ### Hostnames
  #
  # A hostname identifies a server (host) to which requests may be sent:
  #
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     Net::HTTP.start(hostname) do |http|
  #       # Some HTTP stuff.
  #     end
  #
  # ### Paths
  #
  # A host-specific path identifies a resource on the host:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #     hostname = _uri.hostname
  #     path = _uri.path
  #     Net::HTTP.get(hostname, path)
  #
  # ### Queries
  #
  # A host-specific query adds name/value pairs to the URI:
  #
  #     _uri = uri.dup
  #     params = {userId: 1, completed: false}
  #     _uri.query = URI.encode_www_form(params)
  #     _uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com?userId=1&completed=false>
  #     Net::HTTP.get(_uri)
  #
  # ### Fragments
  #
  # A [URI fragment](https://en.wikipedia.org/wiki/URI_fragment) has no effect in
  # Net::HTTP; the same data is returned, regardless of whether a fragment is
  # included.
  #
  # ## Request Headers
  #
  # Request headers may be used to pass additional information to the host,
  # similar to arguments passed in a method call; each header is a name/value
  # pair.
  #
  # Each of the Net::HTTP methods that sends a request to the host has optional
  # argument `headers`, where the headers are expressed as a hash of
  # field-name/value pairs:
  #
  #     headers = {Accept: 'application/json', Connection: 'Keep-Alive'}
  #     Net::HTTP.get(uri, headers)
  #
  # See lists of both standard request fields and common request fields at
  # [Request
  # Fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_field
  # s). A host may also accept other custom fields.
  #
  # ## Sessions
  #
  # A *session* is a connection between a server (host) and a client that:
  #
  # *   Is begun by instance method Net::HTTP#start.
  # *   May contain any number of requests.
  # *   Is ended by instance method Net::HTTP#finish.
  #
  #
  # See example sessions at the [Synopsis](rdoc-ref:Net::HTTP@Synopsis).
  #
  # ### Session Using Net::HTTP.start
  #
  # If you have many requests to make to a single host (and port), consider using
  # singleton method Net::HTTP.start with a block; the method handles the session
  # automatically by:
  #
  # *   Calling #start before block execution.
  # *   Executing the block.
  # *   Calling #finish after block execution.
  #
  #
  # In the block, you can use these instance methods, each of which that sends a
  # single request:
  #
  # *   [HTTP
  #     methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request
  #     _methods):
  #
  #     *   #get, #request_get: GET.
  #     *   #head, #request_head: HEAD.
  #     *   #post, #request_post: POST.
  #     *   #delete: DELETE.
  #     *   #options: OPTIONS.
  #     *   #trace: TRACE.
  #     *   #patch: PATCH.
  #
  #
  # *   [WebDAV methods](https://en.wikipedia.org/wiki/WebDAV#Implementation):
  #
  #     *   #copy: COPY.
  #     *   #lock: LOCK.
  #     *   #mkcol: MKCOL.
  #     *   #move: MOVE.
  #     *   #propfind: PROPFIND.
  #     *   #proppatch: PROPPATCH.
  #     *   #unlock: UNLOCK.
  #
  #
  #
  # ### Session Using Net::HTTP.start and Net::HTTP.finish
  #
  # You can manage a session manually using methods #start and #finish:
  #
  #     http = Net::HTTP.new(hostname)
  #     http.start
  #     http.get('/todos/1')
  #     http.get('/todos/2')
  #     http.delete('/posts/1')
  #     http.finish # Needed to free resources.
  #
  # ### Single-Request Session
  #
  # Certain convenience methods automatically handle a session by:
  #
  # *   Creating an HTTP object
  # *   Starting a session.
  # *   Sending a single request.
  # *   Finishing the session.
  # *   Destroying the object.
  #
  #
  # Such methods that send GET requests:
  #
  # *   ::get: Returns the string response body.
  # *   ::get_print: Writes the string response body to $stdout.
  # *   ::get_response: Returns a Net::HTTPResponse object.
  #
  #
  # Such methods that send POST requests:
  #
  # *   ::post: Posts data to the host.
  # *   ::post_form: Posts form data to the host.
  #
  #
  # ## HTTP Requests and Responses
  #
  # Many of the methods above are convenience methods, each of which sends a
  # request and returns a string without directly using Net::HTTPRequest and
  # Net::HTTPResponse objects.
  #
  # You can, however, directly create a request object, send the request, and
  # retrieve the response object; see:
  #
  # *   Net::HTTPRequest.
  # *   Net::HTTPResponse.
  #
  #
  # ## Following Redirection
  #
  # Each Net::HTTPResponse object belongs to a class for its response code.
  #
  # For example, all 2XX responses are instances of a Net::HTTPSuccess subclass, a
  # 3XX response is an instance of a Net::HTTPRedirection subclass and a 200
  # response is an instance of the Net::HTTPOK class.  For details of response
  # classes, see the section "HTTP Response Classes" below.
  #
  # Using a case statement you can handle various types of responses properly:
  #
  #     def fetch(uri_str, limit = 10)
  #       # You should choose a better exception.
  #       raise ArgumentError, 'too many HTTP redirects' if limit == 0
  #
  #       response = Net::HTTP.get_response(URI(uri_str))
  #
  #       case response
  #       when Net::HTTPSuccess then
  #         response
  #       when Net::HTTPRedirection then
  #         location = response['location']
  #         warn "redirected to #{location}"
  #         fetch(location, limit - 1)
  #       else
  #         response.value
  #       end
  #     end
  #
  #     print fetch('http://www.ruby-lang.org')
  #
  # ## Basic Authentication
  #
  # Basic authentication is performed according to
  # [RFC2617](http://www.ietf.org/rfc/rfc2617.txt).
  #
  #     uri = URI('http://example.com/index.html?key=value')
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req.basic_auth 'user', 'pass'
  #
  #     res = Net::HTTP.start(uri.hostname, uri.port) {|http|
  #       http.request(req)
  #     }
  #     puts res.body
  #
  # ## Streaming Response Bodies
  #
  # By default Net::HTTP reads an entire response into memory.  If you are
  # handling large files or wish to implement a progress bar you can instead
  # stream the body directly to an IO.
  #
  #     uri = URI('http://example.com/large_file')
  #
  #     Net::HTTP.start(uri.host, uri.port) do |http|
  #       request = Net::HTTP::Get.new uri
  #
  #       http.request request do |response|
  #         open 'large_file', 'w' do |io|
  #           response.read_body do |chunk|
  #             io.write chunk
  #           end
  #         end
  #       end
  #     end
  #
  # ## HTTPS
  #
  # HTTPS is enabled for an HTTP connection by Net::HTTP#use_ssl=.
  #
  #     uri = URI('https://secure.example.com/some_path?query=string')
  #
  #     Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
  #       request = Net::HTTP::Get.new uri
  #       response = http.request request # Net::HTTPResponse object
  #     end
  #
  # Or if you simply want to make a GET request, you may pass in an URI object
  # that has an HTTPS URL. Net::HTTP automatically turns on TLS verification if
  # the URI object has a 'https' URI scheme.
  #
  #     uri = URI('https://example.com/')
  #     Net::HTTP.get(uri) # => String
  #
  # In previous versions of Ruby you would need to require 'net/https' to use
  # HTTPS. This is no longer true.
  #
  # ## Proxies
  #
  # Net::HTTP will automatically create a proxy from the `http_proxy` environment
  # variable if it is present.  To disable use of `http_proxy`, pass `nil` for the
  # proxy address.
  #
  # You may also create a custom proxy:
  #
  #     proxy_addr = 'your.proxy.host'
  #     proxy_port = 8080
  #
  #     Net::HTTP.new('example.com', nil, proxy_addr, proxy_port).start { |http|
  #       # always proxy via your.proxy.addr:8080
  #     }
  #
  # See Net::HTTP.new for further details and examples such as proxies that
  # require a username and password.
  #
  # ## Compression
  #
  # Net::HTTP automatically adds Accept-Encoding for compression of response
  # bodies and automatically decompresses gzip and deflate responses unless a
  # Range header was sent.
  #
  # Compression can be disabled through the Accept-Encoding: identity header.
  #
  class HTTP < Protocol
    # :stopdoc:
    VERSION: String

    Revision: untyped

    HTTPVersion: String

    HAVE_ZLIB: bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2()
    # -->
    # Returns `true`; retained for compatibility.
    #
    def self.version_1_2: () -> ::TrueClass

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - version_1_2?()
    # -->
    # Returns `true`; retained for compatibility.
    #
    def self.version_1_2?: () -> ::TrueClass

    def self.version_1_1?: () -> ::FalseClass

    alias self.is_version_1_1? self.version_1_1?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - is_version_1_2?()
    # -->
    #
    alias self.is_version_1_2? self.version_1_2?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get_print(hostname, path, port = 80) -> nil
    #   - Net::HTTP:get_print(uri, headers = {}, port = uri.port) -> nil
    # -->
    # Like Net::HTTP.get, but writes the returned body to $stdout; returns `nil`.
    #
    def self.get_print: (URI::Generic uri, ?Hash[String, untyped] header) -> void
                      | (String host, String path, ?Integer port) -> void

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get(hostname, path, port = 80) -> body
    #   - Net::HTTP:get(uri, headers = {}, port = uri.port) -> body
    # -->
    # Sends a GET request and returns the HTTP response body as a string.
    #
    # With string arguments `hostname` and `path`:
    #
    #     hostname = 'jsonplaceholder.typicode.com'
    #     path = '/todos/1'
    #     puts Net::HTTP.get(hostname, path)
    #
    # Output:
    #
    #     {
    #       "userId": 1,
    #       "id": 1,
    #       "title": "delectus aut autem",
    #       "completed": false
    #     }
    #
    # With URI object `uri` and optional hash argument `headers`:
    #
    #     uri = URI('https://jsonplaceholder.typicode.com/todos/1')
    #     headers = {'Content-type' => 'application/json; charset=UTF-8'}
    #     Net::HTTP.get(uri, headers)
    #
    # Related:
    #
    # *   Net::HTTP::Get: request class for HTTP method `GET`.
    # *   Net::HTTP#get: convenience method for HTTP method `GET`.
    #
    def self.get: (URI::Generic uri, ?Hash[String, untyped] header) -> String
                | (String host, String path, ?Integer port) -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Net::HTTP.get_response(hostname, path, port = 80) -> http_response
    #   - Net::HTTP:get_response(uri, headers = {}, port = uri.port) -> http_response
    # -->
    # Like Net::HTTP.get, but returns a Net::HTTPResponse object instead of the body
    # string.
    #
    def self.get_response: (URI::Generic uri, ?Hash[String, untyped] header) ?{ (Net::HTTPResponse) -> void } -> Net::HTTPResponse
                         | (String host, String path, ?Integer port) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(url, data, header = nil)
    # -->
    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument `url` must be a URL; argument `data` must be a string:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     data = '{"title": "foo", "body": "bar", "userId": 1}'
    #     headers = {'content-type': 'application/json'}
    #     res = Net::HTTP.post(_uri, data, headers) # => #<Net::HTTPCreated 201 Created readbody=true>
    #     puts res.body
    #
    # Output:
    #
    #     {
    #       "title": "foo",
    #       "body": "bar",
    #       "userId": 1,
    #       "id": 101
    #     }
    #
    # Related:
    #
    # *   Net::HTTP::Post: request class for HTTP method `POST`.
    # *   Net::HTTP#post: convenience method for HTTP method `POST`.
    #
    def self.post: (URI::Generic url, String data, ?Hash[String, untyped] header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post_form(url, params)
    # -->
    # Posts data to a host; returns a Net::HTTPResponse object.
    #
    # Argument `url` must be a URI; argument `data` must be a hash:
    #
    #     _uri = uri.dup
    #     _uri.path = '/posts'
    #     data = {title: 'foo', body: 'bar', userId: 1}
    #     res = Net::HTTP.post_form(_uri, data) # => #<Net::HTTPCreated 201 Created readbody=true>
    #     puts res.body
    #
    # Output:
    #
    #     {
    #       "title": "foo",
    #       "body": "bar",
    #       "userId": "1",
    #       "id": 101
    #     }
    #
    def self.post_form: (URI::Generic url, Hash[String, untyped] params) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - default_port()
    # -->
    # Returns intger `80`, the default port to use for HTTP requests:
    #
    #     Net::HTTP.default_port # => 80
    #
    def self.default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - http_default_port()
    # -->
    # Returns integer `80`, the default port to use for HTTP requests:
    #
    #     Net::HTTP.http_default_port # => 80
    #
    def self.http_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - https_default_port()
    # -->
    # Returns integer `443`, the default port to use for HTTPS requests:
    #
    #     Net::HTTP.https_default_port # => 443
    #
    def self.https_default_port: () -> Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) -> http
    #   - HTTP.start(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, opts) {|http| ... } -> object
    # -->
    # Creates a new Net::HTTP object, `http`, via Net::HTTP.new:
    #
    #     Net::HTTP.new(address, port, p_addr, p_port, p_user, p_pass)
    #
    # *   For arguments `hostname` through `p_pass`, see Net::HTTP.new.
    # *   For argument `opts`, see below.
    #
    #
    # Note: If `port` is `nil` and `opts[:use_ssl]` is a truthy value, the value
    # passed to `new` is Net::HTTP.https_default_port, not `port`.
    #
    # With no block given:
    #
    # *   Calls `http.start` with no block (see #start), which opens a TCP
    #     connection and HTTP session.
    # *   Returns `http`.
    # *   The caller should call #finish to close the session:
    #
    #         http = Net::HTTP.start(hostname)
    #         http.started? # => true
    #         http.finish
    #         http.started? # => false
    #
    #
    # With a block given:
    #
    # *   Calls `http.start` with the block (see #start), which:
    #
    #     *   Opens a TCP connection and HTTP session.
    #     *   Calls the block, which may make any number of requests to the host.
    #     *   Closes the HTTP session and TCP connection on block exit.
    #     *   Returns the block's value `object`.
    #
    #
    # *   Returns `object`.
    #
    #
    # Example:
    #
    #     hostname = 'jsonplaceholder.typicode.com'
    #     Net::HTTP.start(hostname) do |http|
    #       puts http.get('/todos/1').body
    #       puts http.get('/todos/2').body
    #     end
    #
    # Output:
    #
    #     {
    #       "userId": 1,
    #       "id": 1,
    #       "title": "delectus aut autem",
    #       "completed": false
    #     }
    #     {
    #       "userId": 1,
    #       "id": 2,
    #       "title": "quis ut nam facilis et officia qui",
    #       "completed": false
    #     }
    #
    # If the last argument given is a hash, it is the `opts` hash, where each key is
    # a method or accessor to be called, and its value is the value to be set.
    #
    # The keys may include:
    #
    # *   #ca_file
    # *   #ca_path
    # *   #cert
    # *   #cert_store
    # *   #ciphers
    # *   #close_on_empty_response
    # *   `ipaddr` (calls #ipaddr=)
    # *   #keep_alive_timeout
    # *   #key
    # *   #open_timeout
    # *   #read_timeout
    # *   #ssl_timeout
    # *   #ssl_version
    # *   `use_ssl` (calls #use_ssl=)
    # *   #verify_callback
    # *   #verify_depth
    # *   #verify_mode
    # *   #write_timeout
    #
    def self.start: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) -> Net::HTTP
                  | [T] (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?Hash[Symbol, untyped]? opt) { (Net::HTTP) -> T } -> T

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - newobj(address, port = nil, p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil, p_no_proxy = nil)
    # -->
    #
    alias self.newobj self.new

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - new(address, port = nil)
    # -->
    # Creates a new Net::HTTP object for the specified server address, without
    # opening the TCP connection or initializing the HTTP session. The `address`
    # should be a DNS hostname or IP address.
    #
    def self.new: (String address, ?Integer? port, ?String | :ENV | nil p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass, ?untyped? p_no_proxy) -> Net::HTTP

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - inspect()
    # -->
    # Returns a string representation of `self`:
    #
    #     Net::HTTP.new(hostname).inspect
    #     # => "#<Net::HTTP jsonplaceholder.typicode.com:80 open=false>"
    #
    def inspect: () -> String

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - set_debug_output(output)
    # -->
    # **WARNING** This method opens a serious security hole. Never use this method
    # in production code.
    #
    # Sets the output stream for debugging:
    #
    #     http = Net::HTTP.new(hostname)
    #     File.open('t.tmp', 'w') do |file|
    #       http.set_debug_output(file)
    #       http.start
    #       http.get('/nosuch/1')
    #       http.finish
    #     end
    #     puts File.read('t.tmp')
    #
    # Output:
    #
    #     opening connection to jsonplaceholder.typicode.com:80...
    #     opened
    #     <- "GET /nosuch/1 HTTP/1.1\r\nAccept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3\r\nAccept: */*\r\nUser-Agent: Ruby\r\nHost: jsonplaceholder.typicode.com\r\n\r\n"
    #     -> "HTTP/1.1 404 Not Found\r\n"
    #     -> "Date: Mon, 12 Dec 2022 21:14:11 GMT\r\n"
    #     -> "Content-Type: application/json; charset=utf-8\r\n"
    #     -> "Content-Length: 2\r\n"
    #     -> "Connection: keep-alive\r\n"
    #     -> "X-Powered-By: Express\r\n"
    #     -> "X-Ratelimit-Limit: 1000\r\n"
    #     -> "X-Ratelimit-Remaining: 999\r\n"
    #     -> "X-Ratelimit-Reset: 1670879660\r\n"
    #     -> "Vary: Origin, Accept-Encoding\r\n"
    #     -> "Access-Control-Allow-Credentials: true\r\n"
    #     -> "Cache-Control: max-age=43200\r\n"
    #     -> "Pragma: no-cache\r\n"
    #     -> "Expires: -1\r\n"
    #     -> "X-Content-Type-Options: nosniff\r\n"
    #     -> "Etag: W/\"2-vyGp6PvFo4RvsFtPoIWeCReyIC8\"\r\n"
    #     -> "Via: 1.1 vegur\r\n"
    #     -> "CF-Cache-Status: MISS\r\n"
    #     -> "Server-Timing: cf-q-config;dur=1.3000000762986e-05\r\n"
    #     -> "Report-To: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=yOr40jo%2BwS1KHzhTlVpl54beJ5Wx2FcG4gGV0XVrh3X9OlR5q4drUn2dkt5DGO4GDcE%2BVXT7CNgJvGs%2BZleIyMu8CLieFiDIvOviOY3EhHg94m0ZNZgrEdpKD0S85S507l1vsEwEHkoTm%2Ff19SiO\"}],\"group\":\"cf-nel\",\"max_age\":604800}\r\n"
    #     -> "NEL: {\"success_fraction\":0,\"report_to\":\"cf-nel\",\"max_age\":604800}\r\n"
    #     -> "Server: cloudflare\r\n"
    #     -> "CF-RAY: 778977dc484ce591-DFW\r\n"
    #     -> "alt-svc: h3=\":443\"; ma=86400, h3-29=\":443\"; ma=86400\r\n"
    #     -> "\r\n"
    #     reading 2 bytes...
    #     -> "{}"
    #     read 2 bytes
    #     Conn keep-alive
    #
    def set_debug_output: (IO output) -> void

    # <!-- rdoc-file=lib/net/http.rb -->
    # The DNS host name or IP address to connect to.
    #
    attr_reader address: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # The port number to connect to.
    #
    attr_reader port: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # The local host used to establish the connection.
    #
    attr_accessor local_host: String

    # <!-- rdoc-file=lib/net/http.rb -->
    # The local port used to establish the connection.
    #
    attr_accessor local_port: Integer

    attr_writer proxy_from_env: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    #
    attr_accessor proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr()
    # -->
    # Returns the IP address for the connection.
    #
    # If the session has not been started, returns the value set by #ipaddr=, or
    # `nil` if it has not been set:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.ipaddr # => nil
    #     http.ipaddr = '172.67.155.76'
    #     http.ipaddr # => "172.67.155.76"
    #
    # If the session has been started, returns the IP address from the socket:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.start
    #     http.ipaddr # => "172.67.155.76"
    #     http.finish
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - ipaddr=(addr)
    # -->
    # Sets the IP address for the connection:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.ipaddr # => nil
    #     http.ipaddr = '172.67.155.76'
    #     http.ipaddr # => "172.67.155.76"
    #
    # The IP address may not be set if the session has been started.
    #
    attr_accessor ipaddr: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Number of seconds to wait for the connection to open. Any number may be used,
    # including Floats for fractional seconds. If the HTTP object cannot open a
    # connection in this many seconds, it raises a Net::OpenTimeout exception. The
    # default value is 60 seconds.
    #
    attr_accessor open_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Number of seconds to wait for one block to be read (via one read(2) call). Any
    # number may be used, including Floats for fractional seconds. If the HTTP
    # object cannot read data in this many seconds, it raises a Net::ReadTimeout
    # exception. The default value is 60 seconds.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - read_timeout=(sec)
    # -->
    # Sets the read timeout, in seconds, for `self` to integer `sec`; the initial
    # value is 60.
    #
    # Argument `sec` must be a non-negative numeric value:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.read_timeout # => 60
    #     http.get('/todos/1') # => #<Net::HTTPOK 200 OK readbody=true>
    #     http.read_timeout = 0
    #     http.get('/todos/1') # Raises Net::ReadTimeout.
    #
    attr_accessor read_timeout: Float | Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Number of seconds to wait for one block to be written (via one write(2) call).
    # Any number may be used, including Floats for fractional seconds. If the HTTP
    # object cannot write data in this many seconds, it raises a Net::WriteTimeout
    # exception. The default value is 60 seconds. Net::WriteTimeout is not raised on
    # Windows.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - write_timeout=(sec)
    # -->
    # Sets the write timeout, in seconds, for `self` to integer `sec`; the initial
    # value is 60.
    #
    # Argument `sec` must be a non-negative numeric value.
    #
    attr_accessor write_timeout: Float | Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - max_retries=(retries)
    # -->
    # Sets the maximum number of times to retry an idempotent request in case of
    # Net::ReadTimeout, IOError, EOFError, Errno::ECONNRESET, Errno::ECONNABORTED,
    # Errno::EPIPE, OpenSSL::SSL::SSLError, Timeout::Error. The initial value is 1.
    #
    # Argument `retries` must be a non-negative numeric value:
    #
    #     http = Net::HTTP.new(hostname)
    #     http.max_retries = 2   # => 2
    #     http.max_retries       # => 2
    #
    attr_accessor max_retries: Integer

    # <!-- rdoc-file=lib/net/http.rb -->
    # Seconds to wait for 100 Continue response. If the HTTP object does not receive
    # a response in this many seconds it sends the request body. The default value
    # is `nil`.
    # ----
    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - continue_timeout=(sec)
    # -->
    # Setter for the continue_timeout attribute.
    #
    attr_accessor continue_timeout: Float | Integer | nil

    # <!-- rdoc-file=lib/net/http.rb -->
    # Seconds to reuse the connection of the previous request. If the idle time is
    # less than this Keep-Alive Timeout, Net::HTTP reuses the TCP/IP socket used by
    # the previous communication. The default value is 2 seconds.
    #
    attr_accessor keep_alive_timeout: Float | Integer

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - started?()
    # -->
    # Returns true if the HTTP session has been started.
    #
    def started?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - active?()
    # -->
    #
    alias active? started?

    attr_accessor close_on_empty_response: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl?()
    # -->
    # Returns true if SSL/TLS is being used with HTTP.
    #
    def use_ssl?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - use_ssl=(flag)
    # -->
    # Turn on/off SSL. This flag must be set before starting session. If you change
    # use_ssl value after session started, a Net::HTTP object raises IOError.
    #
    def use_ssl=: (boolish flag) -> void

    SSL_IVNAMES: Array[untyped]

    SSL_ATTRIBUTES: Array[Symbol]

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets path of a CA certification file in PEM format.
    #
    # The file can contain several CA certificates.
    #
    attr_accessor ca_file: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets path of a CA certification directory containing certifications in PEM
    # format.
    #
    attr_accessor ca_path: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets an OpenSSL::X509::Certificate object as client certificate. (This method
    # is appeared in Michal Rokos's OpenSSL extension).
    #
    attr_accessor cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the X509::Store to verify peer certificate.
    #
    attr_accessor cert_store: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the available ciphers.  See OpenSSL::SSL::SSLContext#ciphers=
    #
    attr_accessor ciphers: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the extra X509 certificates to be added to the certificate chain. See
    # OpenSSL::SSL::SSLContext#extra_chain_cert=
    #
    attr_accessor extra_chain_cert: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets an OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object. (This method is
    # appeared in Michal Rokos's OpenSSL extension.)
    #
    attr_accessor key: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the SSL timeout seconds.
    #
    attr_accessor ssl_timeout: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the SSL version.  See OpenSSL::SSL::SSLContext#ssl_version=
    #
    attr_accessor ssl_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the minimum SSL version.  See OpenSSL::SSL::SSLContext#min_version=
    #
    attr_accessor min_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the maximum SSL version.  See OpenSSL::SSL::SSLContext#max_version=
    #
    attr_accessor max_version: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the verify callback for the server certification verification.
    #
    attr_accessor verify_callback: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the maximum depth for the certificate chain verification.
    #
    attr_accessor verify_depth: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets the flags for server the certification verification at beginning of
    # SSL/TLS session.
    #
    # OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER are acceptable.
    #
    attr_accessor verify_mode: untyped

    # <!-- rdoc-file=lib/net/http.rb -->
    # Sets to check the server certificate is valid for the hostname. See
    # OpenSSL::SSL::SSLContext#verify_hostname=
    #
    attr_accessor verify_hostname: untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - peer_cert()
    # -->
    # Returns the X.509 certificates the server presented.
    #
    def peer_cert: () -> (nil | untyped)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - start() { |http| ... }
    # -->
    # Opens a TCP connection and HTTP session.
    #
    # When this method is called with a block, it passes the Net::HTTP object to the
    # block, and closes the TCP connection and HTTP session after the block has been
    # executed.
    #
    # When called with a block, it returns the return value of the block; otherwise,
    # it returns self.
    #
    def start: [T] () { (Net::HTTP) -> T } -> T
             | () -> Net::HTTP

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - finish()
    # -->
    # Finishes the HTTP session and closes the TCP connection. Raises IOError if the
    # session has not been started.
    #
    def finish: () -> void

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - Proxy(p_addr = :ENV, p_port = nil, p_user = nil, p_pass = nil)
    # -->
    # Creates an HTTP proxy class which behaves like Net::HTTP, but performs all
    # access via the specified proxy.
    #
    # This class is obsolete.  You may pass these same parameters directly to
    # Net::HTTP.new.  See Net::HTTP.new for details of the arguments.
    #
    def self.Proxy: (?Symbol | String p_addr, ?Integer? p_port, ?String? p_user, ?String? p_pass) -> untyped

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_class?()
    # -->
    # returns true if self is a class which was created by HTTP::Proxy.
    #
    def self.proxy_class?: () -> bool

    # <!-- rdoc-file=lib/net/http.rb -->
    # Address of proxy host. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_address: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # Port number of proxy host. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_port: Integer?

    # <!-- rdoc-file=lib/net/http.rb -->
    # User name for accessing proxy. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_user: String?

    # <!-- rdoc-file=lib/net/http.rb -->
    # User password for accessing proxy. If Net::HTTP does not use a proxy, nil.
    #
    attr_reader self.proxy_pass: String?

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy?()
    # -->
    # True if requests for this connection will be proxied
    #
    def proxy?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxy_from_env?()
    # -->
    # True if the proxy for this connection is determined from the environment
    #
    def proxy_from_env?: () -> bool

    def proxy_uri: () -> (nil | URI::Generic)

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyaddr()
    # -->
    #
    alias proxyaddr proxy_address

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proxyport()
    # -->
    #
    alias proxyport proxy_port

    public

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get(path, initheader = nil, dest = nil) { |body_segment| ... }
    # -->
    # Retrieves data from `path` on the connected-to host which may be an absolute
    # path String or a URI to extract the path from.
    #
    # `initheader` must be a Hash like { 'Accept' => '**/**', ... }, and it defaults
    # to an empty hash. If `initheader` doesn't have the key 'accept-encoding', then
    # a value of "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used, so that gzip
    # compression is used in preference to deflate compression, which is used in
    # preference to no compression. Ruby doesn't have libraries to support the
    # compress (Lempel-Ziv) compression, so that is not supported.  The intent of
    # this is to reduce bandwidth by default.   If this routine sets up compression,
    # then it does the decompression also, removing the header as well to prevent
    # confusion.  Otherwise it leaves the body as it found it.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # If called with a block, yields each fragment of the entity body in turn as a
    # string as it is read from the socket.  Note that in this case, the returned
    # response object will **not** contain a (meaningful) body.
    #
    # `dest` argument is obsolete. It still works but you must not use it.
    #
    # This method never raises an exception.
    #
    #     response = http.get('/index.html')
    #
    #     # using block
    #     File.open('result.txt', 'w') {|f|
    #       http.get('/~foo/') do |str|
    #         f.write str
    #       end
    #     }
    #
    def get: (String path, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head(path, initheader = nil)
    # -->
    # Gets only the header from `path` on the connected-to host. `header` is a Hash
    # like { 'Accept' => '**/**', ... }.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # This method never raises an exception.
    #
    #     response = nil
    #     Net::HTTP.start('some.www.server', 80) {|http|
    #       response = http.head('/index.html')
    #     }
    #     p response['content-type']
    #
    def head: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post(path, data, initheader = nil, dest = nil) { |body_segment| ... }
    # -->
    # Posts `data` (must be a String) to `path`. `header` must be a Hash like {
    # 'Accept' => '**/**', ... }.
    #
    # This method returns a Net::HTTPResponse object.
    #
    # If called with a block, yields each fragment of the entity body in turn as a
    # string as it is read from the socket.  Note that in this case, the returned
    # response object will **not** contain a (meaningful) body.
    #
    # `dest` argument is obsolete. It still works but you must not use it.
    #
    # This method never raises exception.
    #
    #     response = http.post('/cgi-bin/search.rb', 'query=foo')
    #
    #     # using block
    #     File.open('result.txt', 'w') {|f|
    #       http.post('/cgi-bin/search.rb', 'query=foo') do |str|
    #         f.write str
    #       end
    #     }
    #
    # You should set Content-Type: header field for POST. If no Content-Type: field
    # given, this method uses "application/x-www-form-urlencoded" by default.
    #
    def post: (String path, String data, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - patch(path, data, initheader = nil, dest = nil) { |body_segment| ... }
    # -->
    # Sends a PATCH request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def patch: (String path, String data, ?Hash[String, untyped] initheader, ?bot dest) ?{ (String body_segment) -> void } -> Net::HTTPResponse

    def put: (String path, String data, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - proppatch(path, body, initheader = nil)
    # -->
    # Sends a PROPPATCH request to the `path` and gets a response, as an
    # HTTPResponse object.
    #
    def proppatch: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - lock(path, body, initheader = nil)
    # -->
    # Sends a LOCK request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def lock: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - unlock(path, body, initheader = nil)
    # -->
    # Sends a UNLOCK request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def unlock: (String path, String body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - options(path, initheader = nil)
    # -->
    # Sends a OPTIONS request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def options: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - propfind(path, body = nil, initheader = {'Depth' => '0'})
    # -->
    # Sends a PROPFIND request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def propfind: (String path, ?untyped? body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - delete(path, initheader = {'Depth' => 'Infinity'})
    # -->
    # Sends a DELETE request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def delete: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - move(path, initheader = nil)
    # -->
    # Sends a MOVE request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def move: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - copy(path, initheader = nil)
    # -->
    # Sends a COPY request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def copy: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - mkcol(path, body = nil, initheader = nil)
    # -->
    # Sends a MKCOL request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def mkcol: (String path, ?untyped? body, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - trace(path, initheader = nil)
    # -->
    # Sends a TRACE request to the `path` and gets a response, as an HTTPResponse
    # object.
    #
    def trace: (String path, ?Hash[String, untyped] initheader) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_get(path, initheader = nil) { |response| ... }
    # -->
    # Sends a GET request to the `path`. Returns the response as a Net::HTTPResponse
    # object.
    #
    # When called with a block, passes an HTTPResponse object to the block. The body
    # of the response will not have been read yet; the block can process it using
    # HTTPResponse#read_body, if desired.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.request_get('/index.html')
    #     # The entity body is already read in this case.
    #     p response['content-type']
    #     puts response.body
    #
    #     # Using a block
    #     http.request_get('/index.html') {|response|
    #       p response['content-type']
    #       response.read_body do |str|   # read body now
    #         print str
    #       end
    #     }
    #
    def request_get: (String path, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_head(path, initheader = nil, &block)
    # -->
    # Sends a HEAD request to the `path` and returns the response as a
    # Net::HTTPResponse object.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.request_head('/index.html')
    #     p response['content-type']
    #
    def request_head: (String path, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request_post(path, data, initheader = nil) { |response| ... }
    # -->
    # Sends a POST request to the `path`.
    #
    # Returns the response as a Net::HTTPResponse object.
    #
    # When called with a block, the block is passed an HTTPResponse object.  The
    # body of that response will not have been read yet; the block can process it
    # using HTTPResponse#read_body, if desired.
    #
    # Returns the response.
    #
    # This method never raises Net::* exceptions.
    #
    #     # example
    #     response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
    #     p response.status
    #     puts response.body          # body is already read in this case
    #
    #     # using block
    #     http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
    #       p response.status
    #       p response['content-type']
    #       response.read_body do |str|   # read body now
    #         print str
    #       end
    #     }
    #
    def request_post: (String path, String data, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    def request_put: (String path, String data, ?Hash[String, untyped] initheader) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - get2(path, initheader = nil)
    # -->
    #
    alias get2 request_get

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - head2(path, initheader = nil, &block)
    # -->
    #
    alias head2 request_head

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - post2(path, data, initheader = nil)
    # -->
    #
    alias post2 request_post

    alias put2 request_put

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - send_request(name, path, data = nil, header = nil)
    # -->
    # Sends an HTTP request to the HTTP server. Also sends a DATA string if `data`
    # is given.
    #
    # Returns a Net::HTTPResponse object.
    #
    # This method never raises Net::* exceptions.
    #
    #     response = http.send_request('GET', '/index.html')
    #     puts response.body
    #
    def send_request: (String name, String path, ?String? data, ?Hash[String, untyped]? header) -> Net::HTTPResponse

    # <!--
    #   rdoc-file=lib/net/http.rb
    #   - request(req, body = nil) { |response| ... }
    # -->
    # Sends an HTTPRequest object `req` to the HTTP server.
    #
    # If `req` is a Net::HTTP::Post or Net::HTTP::Put request containing data, the
    # data is also sent. Providing data for a Net::HTTP::Head or Net::HTTP::Get
    # request results in an ArgumentError.
    #
    # Returns an HTTPResponse object.
    #
    # When called with a block, passes an HTTPResponse object to the block. The body
    # of the response will not have been read yet; the block can process it using
    # HTTPResponse#read_body, if desired.
    #
    # This method never raises Net::* exceptions.
    #
    def request: (Net::HTTPRequest req, ?String? body) ?{ (Net::HTTPResponse response) -> void } -> Net::HTTPResponse
  end

  # <!-- rdoc-file=lib/net/http/generic_request.rb -->
  # HTTPGenericRequest is the parent of the Net::HTTPRequest class. Do not use
  # this directly; use a subclass of Net::HTTPRequest.
  #
  # Mixes in the Net::HTTPHeader module to provide easier access to HTTP headers.
  #
  class HTTPGenericRequest
    include Net::HTTPHeader

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - new(m, reqbody, resbody, uri_or_path, initheader = nil)
    # -->
    #
    def initialize: (String m, boolish reqbody, boolish resbody, URI::Generic | String uri_or_path, ?Hash[String, untyped] initheader) -> Net::HTTP

    attr_reader method: String

    attr_reader path: String

    attr_reader uri: URI::Generic

    # <!-- rdoc-file=lib/net/http/generic_request.rb -->
    # Automatically set to false if the user sets the Accept-Encoding header. This
    # indicates they wish to handle Content-encoding in responses themselves.
    #
    attr_reader decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    def []=: (untyped key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - request_body_permitted?()
    # -->
    #
    def request_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - response_body_permitted?()
    # -->
    #
    def response_body_permitted?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_exist?()
    # -->
    #
    def body_exist?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body=(str)
    # -->
    #
    attr_accessor body: String?

    # <!--
    #   rdoc-file=lib/net/http/generic_request.rb
    #   - body_stream=(input)
    # -->
    #
    attr_accessor body_stream: untyped
  end

  # <!-- rdoc-file=lib/net/http/header.rb -->
  # The HTTPHeader module provides access to HTTP headers.
  #
  # The module is included in:
  #
  # *   Net::HTTPGenericRequest (and therefore Net::HTTPRequest).
  # *   Net::HTTPResponse.
  #
  #
  # The headers are a hash-like collection of key/value pairs called *fields*.
  #
  # ## Request and Response Fields
  #
  # Headers may be included in:
  #
  # *   A Net::HTTPRequest object: the object's headers will be sent with the
  #     request. Any fields may be defined in the request; see
  #     [Setters](rdoc-ref:Net::HTTPHeader@Setters).
  # *   A Net::HTTPResponse object: the objects headers are usually those returned
  #     from the host. Fields may be retrieved from the object; see
  #     [Getters](rdoc-ref:Net::HTTPHeader@Getters) and
  #     [Iterators](rdoc-ref:Net::HTTPHeader@Iterators).
  #
  #
  # Exactly which fields should be sent or expected depends on the host; see:
  #
  # *   [Request
  #     fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_f
  #     ields).
  # *   [Response
  #     fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Response_
  #     fields).
  #
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Fields
  #
  # A header field is a key/value pair.
  #
  # ### Field Keys
  #
  # A field key may be:
  #
  # *   A string: Key `'Accept'` is treated as if it were `'Accept'.downcase`;
  #     i.e., `'accept'`.
  # *   A symbol: Key `:Accept` is treated as if it were `:Accept.to_s.downcase`;
  #     i.e., `'accept'`.
  #
  #
  # Examples:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     req[:accept]  # => "*/*"
  #     req['Accept'] # => "*/*"
  #     req['ACCEPT'] # => "*/*"
  #
  #     req['accept'] = 'text/html'
  #     req[:accept] = 'text/html'
  #     req['ACCEPT'] = 'text/html'
  #
  # ### Field Values
  #
  # A field value may be returned as an array of strings or as a string:
  #
  # *   These methods return field values as arrays:
  #
  #     *   #get_fields: Returns the array value for the given key, or `nil` if it
  #         does not exist.
  #     *   #to_hash: Returns a hash of all header fields: each key is a field
  #         name; its value is the array value for the field.
  #
  #
  # *   These methods return field values as string; the string value for a field
  #     is equivalent to `self[key.downcase.to_s].join(', '))`:
  #
  #     *   #[]: Returns the string value for the given key, or `nil` if it does
  #         not exist.
  #     *   #fetch: Like #[], but accepts a default value to be returned if the
  #         key does not exist.
  #
  #
  #
  # The field value may be set:
  #
  # *   #[]=: Sets the value for the given key; the given value may be a string, a
  #     symbol, an array, or a hash.
  # *   #add_field: Adds a given value to a value for the given key (not
  #     overwriting the existing value).
  # *   #delete: Deletes the field for the given key.
  #
  #
  # Example field values:
  #
  # *   String:
  #
  #         req['Accept'] = 'text/html' # => "text/html"
  #         req['Accept']               # => "text/html"
  #         req.get_fields('Accept')    # => ["text/html"]
  #
  # *   Symbol:
  #
  #         req['Accept'] = :text    # => :text
  #         req['Accept']            # => "text"
  #         req.get_fields('Accept') # => ["text"]
  #
  # *   Simple array:
  #
  #         req[:foo] = %w[bar baz bat]
  #         req[:foo]            # => "bar, baz, bat"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat"]
  #
  # *   Simple hash:
  #
  #         req[:foo] = {bar: 0, baz: 1, bat: 2}
  #         req[:foo]            # => "bar, 0, baz, 1, bat, 2"
  #         req.get_fields(:foo) # => ["bar", "0", "baz", "1", "bat", "2"]
  #
  # *   Nested:
  #
  #         req[:foo] = [%w[bar baz], {bat: 0, bam: 1}]
  #         req[:foo]            # => "bar, baz, bat, 0, bam, 1"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat", "0", "bam", "1"]
  #
  #         req[:foo] = {bar: %w[baz bat], bam: {bah: 0, bad: 1}}
  #         req[:foo]            # => "bar, baz, bat, bam, bah, 0, bad, 1"
  #         req.get_fields(:foo) # => ["bar", "baz", "bat", "bam", "bah", "0", "bad", "1"]
  #
  #
  # ## Convenience Methods
  #
  # Various convenience methods retrieve values, set values, query values, set
  # form values, or iterate over fields.
  #
  # ### Setters
  #
  # Method #[]= can set any field, but does little to validate the new value; some
  # of the other setter methods provide some validation:
  #
  # *   #[]=: Sets the string or array value for the given key.
  # *   #add_field: Creates or adds to the array value for the given key.
  # *   #basic_auth: Sets the string authorization header for `'Authorization'`.
  # *   #content_length=: Sets the integer length for field `'Content-Length`.
  # *   #content_type=: Sets the string value for field `'Content-Type'`.
  # *   #proxy_basic_auth: Sets the string authorization header for
  #     `'Proxy-Authorization'`.
  # *   #set_range: Sets the value for field `'Range'`.
  #
  #
  # ### Form Setters
  #
  # *   #set_form: Sets an HTML form data set.
  # *   #set_form_data: Sets header fields and a body from HTML form data.
  #
  #
  # ### Getters
  #
  # Method #[] can retrieve the value of any field that exists, but always as a
  # string; some of the other getter methods return something different from the
  # simple string value:
  #
  # *   #[]: Returns the string field value for the given key.
  # *   #content_length: Returns the integer value of field `'Content-Length'`.
  # *   #content_range: Returns the Range value of field `'Content-Range'`.
  # *   #content_type: Returns the string value of field `'Content-Type'`.
  # *   #fetch: Returns the string field value for the given key.
  # *   #get_fields: Returns the array field value for the given `key`.
  # *   #main_type: Returns first part of the string value of field
  #     `'Content-Type'`.
  # *   #sub_type: Returns second part of the string value of field
  #     `'Content-Type'`.
  # *   #range: Returns an array of Range objects of field `'Range'`, or `nil`.
  # *   #range_length: Returns the integer length of the range given in field
  #     `'Content-Range'`.
  # *   #type_params: Returns the string parameters for `'Content-Type'`.
  #
  #
  # ### Queries
  #
  # *   #chunked?: Returns whether field `'Transfer-Encoding'` is set to
  #     `'chunked'`.
  # *   #connection_close?: Returns whether field `'Connection'` is set to
  #     `'close'`.
  # *   #connection_keep_alive?: Returns whether field `'Connection'` is set to
  #     `'keep-alive'`.
  # *   #key?: Returns whether a given key exists.
  #
  #
  # ### Iterators
  #
  # *   #each_capitalized: Passes each field capitalized-name/value pair to the
  #     block.
  # *   #each_capitalized_name: Passes each capitalized field name to the block.
  # *   #each_header: Passes each field name/value pair to the block.
  # *   #each_name: Passes each field name to the block.
  # *   #each_value: Passes each string field value to the block.
  #
  module HTTPHeader
    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - initialize_http_header(initheader)
    # -->
    #
    def initialize_http_header: (Hash[untyped, untyped] initheader) -> void

    def size: () -> Integer

    alias length size

    type key = String | Symbol

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - [](key)
    # -->
    # Returns the string field value for the case-insensitive field `key`, or `nil`
    # if there is no such key; see [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Connection'] # => "keep-alive"
    #     res['Nosuch']     # => nil
    #
    # Note that some field values may be retrieved via convenience methods; see
    # [Getters](rdoc-ref:Net::HTTPHeader@Getters).
    #
    def []: (key key) -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - []=(key, val)
    # -->
    # Sets the value for the case-insensitive `key` to `val`, overwriting the
    # previous value if the field exists; see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req['Accept'] # => "*/*"
    #     req['Accept'] = 'text/html'
    #     req['Accept'] # => "text/html"
    #
    # Note that some field values may be set via convenience methods; see
    # [Setters](rdoc-ref:Net::HTTPHeader@Setters).
    #
    def []=: (key key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - add_field(key, val)
    # -->
    # Adds value `val` to the value array for field `key` if the field exists;
    # creates the field with the given `key` and `val` if it does not exist. see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.add_field('Foo', 'bar')
    #     req['Foo']            # => "bar"
    #     req.add_field('Foo', 'baz')
    #     req['Foo']            # => "bar, baz"
    #     req.add_field('Foo', %w[baz bam])
    #     req['Foo']            # => "bar, baz, baz, bam"
    #     req.get_fields('Foo') # => ["bar", "baz", "baz", "bam"]
    #
    def add_field: (key key, untyped val) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_field(key, val)
    # -->
    #
    def set_field: (key key, untyped val) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - append_field_value(ary, val)
    # -->
    #
    def append_field_value: (untyped ary, untyped val) -> void

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - get_fields(key)
    # -->
    # Returns the array field value for the given `key`, or `nil` if there is no
    # such field; see [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.get_fields('Connection') # => ["keep-alive"]
    #     res.get_fields('Nosuch')     # => nil
    #
    def get_fields: (key key) -> (nil | Array[String])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - fetch(key, default_val = nil) {|key| ... } -> object
    #   - fetch(key, default_val = nil) -> value or default_val
    # -->
    # With a block, returns the string value for `key` if it exists; otherwise
    # returns the value of the block; ignores the `default_val`; see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #
    #     # Field exists; block not called.
    #     res.fetch('Connection') do |value|
    #       fail 'Cannot happen'
    #     end # => "keep-alive"
    #
    #     # Field does not exist; block called.
    #     res.fetch('Nosuch') do |value|
    #       value.downcase
    #     end # => "nosuch"
    #
    # With no block, returns the string value for `key` if it exists; otherwise,
    # returns `default_val` if it was given; otherwise raises an exception:
    #
    #     res.fetch('Connection', 'Foo') # => "keep-alive"
    #     res.fetch('Nosuch', 'Foo')     # => "Foo"
    #     res.fetch('Nosuch')            # Raises KeyError.
    #
    def fetch: (key key) -> String
             | (key key, untyped) -> untyped
             | (key key) { (String) -> untyped } -> untyped

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_header() { |key| ... }
    # -->
    # Calls the block with each key/value pair:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_header do |key, value|
    #       p [key, value] if key.start_with?('c')
    #     end
    #
    # Output:
    #
    #     ["content-type", "application/json; charset=utf-8"]
    #     ["connection", "keep-alive"]
    #     ["cache-control", "max-age=43200"]
    #     ["cf-cache-status", "HIT"]
    #     ["cf-ray", "771d17e9bc542cf5-ORD"]
    #
    # Returns an enumerator if no block is given.
    #
    # Net::HTTPHeader#each is an alias for Net::HTTPHeader#each_header.
    #
    def each_header: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                   | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each()
    # -->
    #
    alias each each_header

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_name() { |key| ... }
    # -->
    # Calls the block with each field key:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_key do |key|
    #       p key if key.start_with?('c')
    #     end
    #
    # Output:
    #
    #     "content-type"
    #     "connection"
    #     "cache-control"
    #     "cf-cache-status"
    #     "cf-ray"
    #
    # Returns an enumerator if no block is given.
    #
    # Net::HTTPHeader#each_name is an alias for Net::HTTPHeader#each_key.
    #
    def each_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                 | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_key()
    # -->
    #
    alias each_key each_name

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized_name() { |key| ... }
    # -->
    # Calls the block with each capitalized field name:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_capitalized_name do |key|
    #       p key if key.start_with?('C')
    #     end
    #
    # Output:
    #
    #     "Content-Type"
    #     "Connection"
    #     "Cache-Control"
    #     "Cf-Cache-Status"
    #     "Cf-Ray"
    #
    # The capitalization is system-dependent; see [Case
    # Mapping](rdoc-ref:case_mapping.rdoc).
    #
    # Returns an enumerator if no block is given.
    #
    def each_capitalized_name: () { (String) -> untyped } -> Hash[String, Array[String]]
                             | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_value() { |value| ... }
    # -->
    # Calls the block with each string field value:
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.each_value do |value|
    #       p value if value.start_with?('c')
    #     end
    #
    # Output:
    #
    #     "chunked"
    #     "cf-q-config;dur=6.0000002122251e-06"
    #     "cloudflare"
    #
    # Returns an enumerator if no block is given.
    #
    def each_value: () { (String) -> untyped } -> Hash[String, Array[String]]
                  | () -> Enumerator[String, Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - delete(key)
    # -->
    # Removes the header for the given case-insensitive `key` (see
    # [Fields](rdoc-ref:Net::HTTPHeader@Fields)); returns the deleted value, or
    # `nil` if no such field exists:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.delete('Accept') # => ["*/*"]
    #     req.delete('Nosuch') # => nil
    #
    def delete: (key key) -> (Array[String] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - key?(key)
    # -->
    # Returns `true` if the field for the case-insensitive `key` exists, `false`
    # otherwise:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.key?('Accept') # => true
    #     req.key?('Nosuch') # => false
    #
    def key?: (key key) -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - to_hash()
    # -->
    # Returns a hash of the key/value pairs:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.to_hash
    #     # =>
    #     {"accept-encoding"=>["gzip;q=1.0,deflate;q=0.6,identity;q=0.3"],
    #      "accept"=>["*/*"],
    #      "user-agent"=>["Ruby"],
    #      "host"=>["jsonplaceholder.typicode.com"]}
    #
    def to_hash: () -> Hash[String, Array[String]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - each_capitalized() { |capitalize(k), join(', ')| ... }
    # -->
    # Like #each_header, but the keys are returned in capitalized form.
    #
    # Net::HTTPHeader#canonical_each is an alias for
    # Net::HTTPHeader#each_capitalized.
    #
    def each_capitalized: () { (String, String) -> untyped } -> Hash[String, Array[String]]
                        | () -> Enumerator[[ String, String ], Hash[String, Array[String]]]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - canonical_each()
    # -->
    #
    alias canonical_each each_capitalized

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - capitalize(name)
    # -->
    #
    def capitalize: (key name) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range()
    # -->
    # Returns an array of Range objects that represent the value of field `'Range'`,
    # or `nil` if there is no such field; see [Range request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request
    # -header):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req['Range'] = 'bytes=0-99,200-299,400-499'
    #     req.range # => [0..99, 200..299, 400..499]
    #     req.delete('Range')
    #     req.range # # => nil
    #
    def range: () -> (nil | Array[Range[Integer]])

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_range(length) -> length
    #   - set_range(offset, length) -> range
    #   - set_range(begin..length) -> range
    # -->
    # Sets the value for field `'Range'`; see [Range request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#range-request
    # -header):
    #
    # With argument `length`:
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.set_range(100)      # => 100
    #     req['Range']            # => "bytes=0-99"
    #
    # With arguments `offset` and `length`:
    #
    #     req.set_range(100, 100) # => 100...200
    #     req['Range']            # => "bytes=100-199"
    #
    # With argument `range`:
    #
    #     req.set_range(100..199) # => 100..199
    #     req['Range']            # => "bytes=100-199"
    #
    # Net::HTTPHeader#range= is an alias for Net::HTTPHeader#set_range.
    #
    def set_range: (Range[Integer] | Numeric r, ?Integer? e) -> Range[Integer]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range=(r, e = nil)
    # -->
    #
    alias range= set_range

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length()
    # -->
    # Returns the value of field `'Content-Length'` as an integer, or `nil` if there
    # is no such field; see [Content-Length request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-lengt
    # h-request-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/nosuch/1')
    #     res.content_length # => 2
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res.content_length # => nil
    #
    def content_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_length=(len)
    # -->
    # Sets the value of field `'Content-Length'` to the given numeric; see
    # [Content-Length response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-lengt
    # h-response-header):
    #
    #     _uri = uri.dup
    #     hostname = _uri.hostname           # => "jsonplaceholder.typicode.com"
    #     _uri.path = '/posts'               # => "/posts"
    #     req = Net::HTTP::Post.new(_uri)    # => #<Net::HTTP::Post POST>
    #     req.body = '{"title": "foo","body": "bar","userId": 1}'
    #     req.content_length = req.body.size # => 42
    #     req.content_type = 'application/json'
    #     res = Net::HTTP.start(hostname) do |http|
    #       http.request(req)
    #     end # => #<Net::HTTPCreated 201 Created readbody=true>
    #
    def content_length=: (Integer len) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - chunked?()
    # -->
    # Returns `true` if field `'Transfer-Encoding'` exists and has value
    # `'chunked'`, `false` otherwise; see [Transfer-Encoding response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#transfer-enco
    # ding-response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Transfer-Encoding'] # => "chunked"
    #     res.chunked?             # => true
    #
    def chunked?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_range()
    # -->
    # Returns a Range object representing the value of field `'Content-Range'`, or
    # `nil` if no such field exists; see [Content-Range response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range
    # -response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Content-Range'] # => nil
    #     res['Content-Range'] = 'bytes 0-499/1000'
    #     res['Content-Range'] # => "bytes 0-499/1000"
    #     res.content_range    # => 0..499
    #
    def content_range: () -> (Range[Integer] | nil)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - range_length()
    # -->
    # Returns the integer representing length of the value of field
    # `'Content-Range'`, or `nil` if no such field exists; see [Content-Range
    # response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-range
    # -response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['Content-Range'] # => nil
    #     res['Content-Range'] = 'bytes 0-499/1000'
    #     res.range_length     # => 500
    #
    def range_length: () -> (nil | Integer)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type()
    # -->
    # Returns the [media type](https://en.wikipedia.org/wiki/Media_type) from the
    # value of field `'Content-Type'`, or `nil` if no such field exists; see
    # [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.content_type    # => "application/json"
    #
    def content_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - main_type()
    # -->
    # Returns the leading ('type') part of the [media
    # type](https://en.wikipedia.org/wiki/Media_type) from the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.main_type       # => "application"
    #
    def main_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - sub_type()
    # -->
    # Returns the trailing ('subtype') part of the [media
    # type](https://en.wikipedia.org/wiki/Media_type) from the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.sub_type        # => "json"
    #
    def sub_type: () -> (nil | String)

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - type_params()
    # -->
    # Returns the trailing ('parameters') part of the value of field
    # `'Content-Type'`, or `nil` if no such field exists; see [Content-Type response
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # response-header):
    #
    #     res = Net::HTTP.get_response(hostname, '/todos/1')
    #     res['content-type'] # => "application/json; charset=utf-8"
    #     res.type_params     # => {"charset"=>"utf-8"}
    #
    def type_params: () -> Hash[untyped, untyped]

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_content_type(type, params = {})
    # -->
    # Sets the value of field `'Content-Type'`; returns the new value; see
    # [Content-Type request
    # header](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-type-
    # request-header):
    #
    #     req = Net::HTTP::Get.new(uri)
    #     req.set_content_type('application/json') # => ["application/json"]
    #
    # Net::HTTPHeader#content_type= is an alias for
    # Net::HTTPHeader#set_content_type.
    #
    def set_content_type: (key `type`, ?Hash[untyped, untyped] params) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - content_type=(type, params = {})
    # -->
    #
    alias content_type= set_content_type

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form_data(params, sep = '&')
    # -->
    # Set header fields and a body from HTML form data. `params` should be an Array
    # of Arrays or a Hash containing HTML form data. Optional argument `sep` means
    # data record separator.
    #
    # Values are URL encoded as necessary and the content-type is set to
    # application/x-www-form-urlencoded
    #
    # Example:
    #
    #     http.form_data = {"q" => "ruby", "lang" => "en"}
    #     http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
    #     http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')
    #
    # Net::HTTPHeader#form_data= is an alias for Net::HTTPHeader#set_form_data.
    #
    def set_form_data: (Hash[untyped, untyped] params, ?String sep) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - form_data=(params, sep = '&')
    # -->
    #
    alias form_data= set_form_data

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - set_form(params, enctype='application/x-www-form-urlencoded', formopt={})
    # -->
    # Set an HTML form data set.
    # `params`
    # :   The form data to set, which should be an enumerable. See below for more
    #     details.
    # `enctype`
    # :   The content type to use to encode the form submission, which should be
    #     application/x-www-form-urlencoded or multipart/form-data.
    # `formopt`
    # :   An options hash, supporting the following options:
    #     :boundary
    # :       The boundary of the multipart message. If not given, a random boundary
    #         will be used.
    #     :charset
    # :       The charset of the form submission. All field names and values of
    #         non-file fields should be encoded with this charset.
    #
    #
    #
    # Each item of params should respond to `each` and yield 2-3 arguments, or an
    # array of 2-3 elements. The arguments yielded should be:
    #
    # *   The name of the field.
    # *   The value of the field, it should be a String or a File or IO-like.
    # *   An options hash, supporting the following options (used only for file
    #     uploads); entries:
    #
    #     *   `:filename`: The name of the file to use.
    #     *   `:content_type`: The content type of the uploaded file.
    #
    #
    #
    # Each item is a file field or a normal field. If `value` is a File object or
    # the `opt` hash has a :filename key, the item is treated as a file field.
    #
    # If Transfer-Encoding is set as chunked, this sends the request using chunked
    # encoding. Because chunked encoding is HTTP/1.1 feature, you should confirm
    # that the server supports HTTP/1.1 before using chunked encoding.
    #
    # Example:
    #
    #     req.set_form([["q", "ruby"], ["lang", "en"]])
    #
    #     req.set_form({"f"=>File.open('/path/to/filename')},
    #                  "multipart/form-data",
    #                  charset: "UTF-8",
    #     )
    #
    #     req.set_form([["f",
    #                    File.open('/path/to/filename.bar'),
    #                    {filename: "other-filename.foo"}
    #                  ]],
    #                  "multipart/form-data",
    #     )
    #
    # See also RFC 2388, RFC 2616, HTML 4.01, and HTML5
    #
    def set_form: (Hash[untyped, untyped] params, ?String enctype, ?Hash[untyped, untyped] formopt) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_auth(account, password)
    # -->
    # Set the Authorization: header for "Basic" authorization.
    #
    def basic_auth: (String account, String password) -> void

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - proxy_basic_auth(account, password)
    # -->
    # Set Proxy-Authorization: header for "Basic" authorization.
    #
    def proxy_basic_auth: (String account, String password) -> void

    private

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - basic_encode(account, password)
    # -->
    #
    def basic_encode: (String account, String password) -> String

    public

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_close?()
    # -->
    #
    def connection_close?: () -> bool

    # <!--
    #   rdoc-file=lib/net/http/header.rb
    #   - connection_keep_alive?()
    # -->
    #
    def connection_keep_alive?: () -> bool
  end

  # <!-- rdoc-file=lib/net/http/request.rb -->
  # This class is the base class for Net::HTTP request classes; it wraps together
  # the request path and the request headers.
  #
  # The class should not be used directly; instead you should use its subclasses.
  #
  # Subclasses for HTTP requests:
  #
  # *   Net::HTTP::Get
  # *   Net::HTTP::Head
  # *   Net::HTTP::Post
  # *   Net::HTTP::Put
  # *   Net::HTTP::Delete
  # *   Net::HTTP::Options
  # *   Net::HTTP::Trace
  # *   Net::HTTP::Patch
  #
  #
  # Subclasses for WebDAV requests:
  #
  # *   Net::HTTP::Propfind
  # *   Net::HTTP::Proppatch
  # *   Net::HTTP::Mkcol
  # *   Net::HTTP::Copy
  # *   Net::HTTP::Move
  # *   Net::HTTP::Lock
  # *   Net::HTTP::Unlock
  #
  class HTTPRequest < HTTPGenericRequest
    # <!--
    #   rdoc-file=lib/net/http/request.rb
    #   - new(path, initheader = nil)
    # -->
    # Creates an HTTP request object for `path`.
    #
    # `initheader` are the default headers to use.  Net::HTTP adds Accept-Encoding
    # to enable compression of the response body unless Accept-Encoding or Range are
    # supplied in `initheader`.
    #
    def initialize: (String path, ?Hash[String, untyped] initheader) -> void
                  | (URI::Generic uri, ?Hash[String, untyped] initheader) -> void
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # GET](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#GE
  # T_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Get.new(uri) # => #<Net::HTTP::Get GET>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  #
  # Related:
  #
  # *   Net::HTTP.get: sends `GET` request, returns response body.
  # *   Net::HTTP#get: sends `GET` request, returns response object.
  #
  class HTTP::Get < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # HEAD](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#H
  # EAD_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Head.new(uri) # => #<Net::HTTP::Head HEAD>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: no.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  #
  # Related:
  #
  # *   Net::HTTP#head: sends `HEAD` request, returns response object.
  #
  class HTTP::Head < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # POST](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#P
  # OST_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Post.new(uri) # => #<Net::HTTP::Post POST>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): no.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): yes.
  #
  #
  # Related:
  #
  # *   Net::HTTP.post: sends `POST` request, returns response object.
  # *   Net::HTTP#post: sends `POST` request, returns response object.
  #
  class HTTP::Post < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # PUT](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#PU
  # T_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Put.new(uri) # => #<Net::HTTP::Put PUT>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  class HTTP::Put < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # DELETE](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol
  # #DELETE_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts/1'
  #     req = Net::HTTP::Delete.new(uri) # => #<Net::HTTP::Delete DELETE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#delete: sends `DELETE` request, returns response object.
  #
  class HTTP::Delete < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # OPTIONS](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protoco
  # l#OPTIONS_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Options.new(uri) # => #<Net::HTTP::Options OPTIONS>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: optional.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#options: sends `OPTIONS` request, returns response object.
  #
  class HTTP::Options < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # TRACE](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#
  # TRACE_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Trace.new(uri) # => #<Net::HTTP::Trace TRACE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: no.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): yes.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): yes.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#trace: sends `TRACE` request, returns response object.
  #
  class HTTP::Trace < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [HTTP method
  # PATCH](https://en.wikipedia.org/w/index.php?title=Hypertext_Transfer_Protocol#
  # PATCH_method):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     uri.path = '/posts'
  #     req = Net::HTTP::Patch.new(uri) # => #<Net::HTTP::Patch PATCH>
  #     req.body = '{"title": "foo","body": "bar","userId": 1}'
  #     req.content_type = 'application/json'
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Properties:
  #
  # *   Request body: yes.
  # *   Response body: yes.
  # *   [Safe](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_meth
  #     ods): no.
  # *   [Idempotent](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Ide
  #     mpotent_methods): no.
  # *   [Cacheable](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Cach
  #     eable_methods): no.
  #
  #
  # Related:
  #
  # *   Net::HTTP#patch: sends `PATCH` request, returns response object.
  #
  class HTTP::Patch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # PROPFIND](http://www.webdav.org/specs/rfc4918.html#METHOD_PROPFIND):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Propfind.new(uri) # => #<Net::HTTP::Propfind PROPFIND>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#propfind: sends `PROPFIND` request, returns response object.
  #
  class HTTP::Propfind < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # PROPPATCH](http://www.webdav.org/specs/rfc4918.html#METHOD_PROPPATCH):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Proppatch.new(uri) # => #<Net::HTTP::Proppatch PROPPATCH>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#proppatch: sends `PROPPATCH` request, returns response object.
  #
  class HTTP::Proppatch < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # MKCOL](http://www.webdav.org/specs/rfc4918.html#METHOD_MKCOL):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Mkcol.new(uri) # => #<Net::HTTP::Mkcol MKCOL>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#mkcol: sends `MKCOL` request, returns response object.
  #
  class HTTP::Mkcol < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # COPY](http://www.webdav.org/specs/rfc4918.html#METHOD_COPY):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Copy.new(uri) # => #<Net::HTTP::Copy COPY>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#copy: sends `COPY` request, returns response object.
  #
  class HTTP::Copy < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # MOVE](http://www.webdav.org/specs/rfc4918.html#METHOD_MOVE):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Move.new(uri) # => #<Net::HTTP::Move MOVE>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#move: sends `MOVE` request, returns response object.
  #
  class HTTP::Move < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # LOCK](http://www.webdav.org/specs/rfc4918.html#METHOD_LOCK):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Lock.new(uri) # => #<Net::HTTP::Lock LOCK>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#lock: sends `LOCK` request, returns response object.
  #
  class HTTP::Lock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/requests.rb -->
  # Class for representing [WebDAV method
  # UNLOCK](http://www.webdav.org/specs/rfc4918.html#METHOD_UNLOCK):
  #
  #     require 'net/http'
  #     uri = URI('http://example.com')
  #     hostname = uri.hostname # => "example.com"
  #     req = Net::HTTP::Unlock.new(uri) # => #<Net::HTTP::Unlock UNLOCK>
  #     res = Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end
  #
  # Related:
  #
  # *   Net::HTTP#unlock: sends `UNLOCK` request, returns response object.
  #
  class HTTP::Unlock < HTTPRequest
    METHOD: String

    REQUEST_HAS_BODY: bool

    RESPONSE_HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # This class is the base class for Net::HTTP request classes.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Returned Responses
  #
  # Method Net::HTTP.get_response returns an instance of one of the subclasses of
  # Net::HTTPResponse:
  #
  #     Net::HTTP.get_response(uri)
  #     # => #<Net::HTTPOK 200 OK readbody=true>
  #     Net::HTTP.get_response(hostname, '/nosuch')
  #     # => #<Net::HTTPNotFound 404 Not Found readbody=true>
  #
  # As does method Net::HTTP#request:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Class Net::HTTPResponse includes module Net::HTTPHeader, which provides access
  # to response header values via (among others):
  #
  # *   Hash-like method `[]`.
  # *   Specific reader methods, such as `content_type`.
  #
  #
  # Examples:
  #
  #     res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
  #     res['Content-Type']               # => "text/html; charset=UTF-8"
  #     res.content_type                  # => "text/html"
  #
  # ## Response Subclasses
  #
  # Class Net::HTTPResponse has a subclass for each [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can look
  # up the response class for a given code:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
  #     Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
  #
  # And you can retrieve the status code for a response object:
  #
  #     Net::HTTP.get_response(uri).code                 # => "200"
  #     Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
  #
  # The response subclasses (indentation shows class hierarchy):
  #
  # *   Net::HTTPUnknownResponse (for unhandled HTTP extensions).
  #
  # *   Net::HTTPInformation:
  #
  #     *   Net::HTTPContinue (100)
  #     *   Net::HTTPSwitchProtocol (101)
  #     *   Net::HTTPProcessing (102)
  #     *   Net::HTTPEarlyHints (103)
  #
  #
  # *   Net::HTTPSuccess:
  #
  #     *   Net::HTTPOK (200)
  #     *   Net::HTTPCreated (201)
  #     *   Net::HTTPAccepted (202)
  #     *   Net::HTTPNonAuthoritativeInformation (203)
  #     *   Net::HTTPNoContent (204)
  #     *   Net::HTTPResetContent (205)
  #     *   Net::HTTPPartialContent (206)
  #     *   Net::HTTPMultiStatus (207)
  #     *   Net::HTTPAlreadyReported (208)
  #     *   Net::HTTPIMUsed (226)
  #
  #
  # *   Net::HTTPRedirection:
  #
  #     *   Net::HTTPMultipleChoices (300)
  #     *   Net::HTTPMovedPermanently (301)
  #     *   Net::HTTPFound (302)
  #     *   Net::HTTPSeeOther (303)
  #     *   Net::HTTPNotModified (304)
  #     *   Net::HTTPUseProxy (305)
  #     *   Net::HTTPTemporaryRedirect (307)
  #     *   Net::HTTPPermanentRedirect (308)
  #
  #
  # *   Net::HTTPClientError:
  #
  #     *   Net::HTTPBadRequest (400)
  #     *   Net::HTTPUnauthorized (401)
  #     *   Net::HTTPPaymentRequired (402)
  #     *   Net::HTTPForbidden (403)
  #     *   Net::HTTPNotFound (404)
  #     *   Net::HTTPMethodNotAllowed (405)
  #     *   Net::HTTPNotAcceptable (406)
  #     *   Net::HTTPProxyAuthenticationRequired (407)
  #     *   Net::HTTPRequestTimeOut (408)
  #     *   Net::HTTPConflict (409)
  #     *   Net::HTTPGone (410)
  #     *   Net::HTTPLengthRequired (411)
  #     *   Net::HTTPPreconditionFailed (412)
  #     *   Net::HTTPRequestEntityTooLarge (413)
  #     *   Net::HTTPRequestURITooLong (414)
  #     *   Net::HTTPUnsupportedMediaType (415)
  #     *   Net::HTTPRequestedRangeNotSatisfiable (416)
  #     *   Net::HTTPExpectationFailed (417)
  #     *   Net::HTTPMisdirectedRequest (421)
  #     *   Net::HTTPUnprocessableEntity (422)
  #     *   Net::HTTPLocked (423)
  #     *   Net::HTTPFailedDependency (424)
  #     *   Net::HTTPUpgradeRequired (426)
  #     *   Net::HTTPPreconditionRequired (428)
  #     *   Net::HTTPTooManyRequests (429)
  #     *   Net::HTTPRequestHeaderFieldsTooLarge (431)
  #     *   Net::HTTPUnavailableForLegalReasons (451)
  #
  #
  # *   Net::HTTPServerError:
  #
  #     *   Net::HTTPInternalServerError (500)
  #     *   Net::HTTPNotImplemented (501)
  #     *   Net::HTTPBadGateway (502)
  #     *   Net::HTTPServiceUnavailable (503)
  #     *   Net::HTTPGatewayTimeOut (504)
  #     *   Net::HTTPVersionNotSupported (505)
  #     *   Net::HTTPVariantAlsoNegotiates (506)
  #     *   Net::HTTPInsufficientStorage (507)
  #     *   Net::HTTPLoopDetected (508)
  #     *   Net::HTTPNotExtended (510)
  #     *   Net::HTTPNetworkAuthenticationRequired (511)
  #
  #
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTPResponse
    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body_permitted?()
    # -->
    # true if the response has a body.
    #
    def self.body_permitted?: () -> bool

    public

    include Net::HTTPHeader

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP version supported by the server.
    #
    attr_reader http_version: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result code string. For example, '302'.  You can also determine the
    # response type by examining which response subclass the response object is an
    # instance of.
    #
    attr_reader code: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    attr_reader message: String

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The HTTP result message sent by the server. For example, 'Not Found'.
    #
    alias msg message

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # The URI used to fetch this response.  The response URI is only available if a
    # URI was used to create the request.
    #
    attr_reader uri: URI::Generic | nil

    # <!-- rdoc-file=lib/net/http/response.rb -->
    # Set to true automatically when the request did not contain an Accept-Encoding
    # header from the user.
    #
    attr_accessor decode_content: bool

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - inspect()
    # -->
    #
    def inspect: () -> String

    def code_type: () -> untyped

    def error!: () -> untyped

    def error_type: () -> (Net::HTTPError | Net::HTTPServerException | Net::HTTPRetriableError | Net::HTTPFatalError)

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - value()
    # -->
    # Raises an HTTP error if the response is not 2xx (success).
    #
    def value: () -> (nil | untyped)

    def uri=: (URI::Generic uri) -> void

    interface _Dest
      def <<: (String) -> void
    end

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - read_body(dest = nil, &block)
    # -->
    # Gets the entity body returned by the remote HTTP server.
    #
    # If a block is given, the body is passed to the block, and the body is provided
    # in fragments, as it is read in from the socket.
    #
    # If `dest` argument is given, response is read into that variable, with
    # `dest#<<` method (it could be String or IO, or any other object responding to
    # `<<`).
    #
    # Calling this method a second or subsequent time for the same HTTPResponse
    # object will return the value already read.
    #
    #     http.request_get('/index.html') {|res|
    #       puts res.read_body
    #     }
    #
    #     http.request_get('/index.html') {|res|
    #       p res.read_body.object_id   # 538149362
    #       p res.read_body.object_id   # 538149362
    #     }
    #
    #     # using iterator
    #     http.request_get('/index.html') {|res|
    #       res.read_body do |segment|
    #         print segment
    #       end
    #     }
    #
    def read_body: () -> String
                 | (_Dest dest) -> String
                 | () { (String) -> void } -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body()
    # -->
    # Returns the full entity body.
    #
    # Calling this method a second or subsequent time will return the string already
    # read.
    #
    #     http.request_get('/index.html') {|res|
    #       puts res.body
    #     }
    #
    #     http.request_get('/index.html') {|res|
    #       p res.body.object_id   # 538149362
    #       p res.body.object_id   # 538149362
    #     }
    #
    def body: () -> String

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - body=(value)
    # -->
    # Because it may be necessary to modify the body, Eg, decompression this method
    # facilitates that.
    #
    def body=: (untyped value) -> void

    # <!--
    #   rdoc-file=lib/net/http/response.rb
    #   - entity()
    # -->
    #
    alias entity body
  end

  class HTTPUnknownResponse < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for informational (1xx) HTTP response classes.
  #
  # An informational response indicates that the request was received and
  # understood.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.1xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#1xx_in
  #     formational_response).
  #
  class HTTPInformation < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for success (2xx) HTTP response classes.
  #
  # A success response indicates the action requested by the client was received,
  # understood, and accepted.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.2xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_su
  #     ccess).
  #
  class HTTPSuccess < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for redirection (3xx) HTTP response classes.
  #
  # A redirection response indicates the client must take additional action to
  # complete the request.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.3xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_re
  #     direction).
  #
  class HTTPRedirection < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPRetriableError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for client error (4xx) HTTP response classes.
  #
  # A client error response indicates that the client may have caused an error.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.4xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_cl
  #     ient_errors).
  #
  class HTTPClientError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: untyped
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Parent class for server error (5xx) HTTP response classes.
  #
  # A server error response indicates that the server failed to fulfill a request.
  #
  # References:
  #
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#status.5xx).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_se
  #     rver_errors).
  #
  class HTTPServerError < HTTPResponse
    HAS_BODY: bool

    EXCEPTION_TYPE: Net::HTTPFatalError
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Continue` responses (status code 100).
  #
  # A `Continue` response indicates that the server has received the request
  # headers.
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100).
  # *   [RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-100-continue).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#100).
  #
  class HTTPContinue < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Switching Protocol` responses (status code 101).
  #
  # The <tt>Switching Protocol<tt> response indicates that the server has received
  # a request to switch protocols, and has agreed to do so.
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101).
  # *   [RFC
  #     9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-101-switching-proto
  #     cols).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#101).
  #
  class HTTPSwitchProtocol < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Processing` responses (status code 102).
  #
  # The `Processing` response indicates that the server has received and is
  # processing the request, but no response is available yet.
  #
  # References:
  #
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#102).
  #
  class HTTPProcessing < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Early Hints` responses (status code 103).
  #
  # The `Early Hints` indicates that the server has received and is processing the
  # request, and contains certain headers; the final response is not available
  # yet.
  #
  # References:
  #
  # *   [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).
  # *   [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#103).
  #
  class HTTPEarlyHints < HTTPInformation
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `OK` responses (status code 200).
  #
  # The `OK` response indicates that the server has received a request and has
  # responded successfully. See [200
  # OK](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#200).
  #
  class HTTPOK < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Created` responses (status code 201).
  #
  # The `Created` response indicates that the server has received and has
  # fulfilled a request to create a new resource. See [201
  # Created](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#201).
  #
  class HTTPCreated < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Accepted` responses (status code 202).
  #
  # The `Accepted` response indicates that the server has received and is
  # processing a request, but the processing has not yet been completed. See [202
  # Accepted](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#202).
  #
  class HTTPAccepted < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Non-Authoritative Information` responses (status code
  # 203).
  #
  # The `Non-Authoritative Information` response indicates that the server is a
  # transforming proxy (such as a Web accelerator) that received a 200 OK response
  # from its origin, and is returning a modified version of the origin's response.
  # See [203 Non-Authoritative
  # Information](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#203).
  #
  class HTTPNonAuthoritativeInformation < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `No Content` responses (status code 204).
  #
  # The `No Content` response indicates that the server successfully processed the
  # request, and is not returning any content. See [204 No
  # Content](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#204).
  #
  class HTTPNoContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Reset Content` responses (status code 205).
  #
  # The `Reset Content` response indicates that the server successfully processed
  # the request, asks that the client reset its document view, and is not
  # returning any content. See [205 Reset
  # Content](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#205).
  #
  class HTTPResetContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Partial Content` responses (status code 206).
  #
  # The `Partial Content` response indicates that the server is delivering only
  # part of the resource (byte serving) due to a Range header in the request. See
  # [206 Partial
  # Content](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#206).
  #
  class HTTPPartialContent < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multi-Status (WebDAV)` responses (status code 207).
  #
  # The `Multi-Status (WebDAV)` response indicates that the server has received
  # the request, and that the message body can contain a number of separate
  # response codes. See [207 Multi-Status
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#207).
  #
  class HTTPMultiStatus < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Already Reported (WebDAV)` responses (status code 208).
  #
  # The `Already Reported (WebDAV)` response indicates that the server has
  # received the request, and that the members of a DAV binding have already been
  # enumerated in a preceding part of the (multi-status) response, and are not
  # being included again. See [208 Already Reported
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#208).
  #
  class HTTPAlreadyReported < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `IM Used` responses (status code 226).
  #
  # The `IM Used` response indicates that the server has fulfilled a request for
  # the resource, and the response is a representation of the result of one or
  # more instance-manipulations applied to the current instance. See [226 IM
  # Used](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#226).
  #
  class HTTPIMUsed < HTTPSuccess
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multiple Choices` responses (status code 300).
  #
  # The `Multiple Choices` response indicates that the server offers multiple
  # options for the resource from which the client may choose. See [300 Multiple
  # Choices](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#300).
  #
  class HTTPMultipleChoices < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Multiple Choices` responses (status code 300).
  #
  # The `Multiple Choices` response indicates that the server offers multiple
  # options for the resource from which the client may choose. See [300 Multiple
  # Choices](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#300).
  #
  HTTPMultipleChoice: HTTPMultipleChoices

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Moved Permanently` responses (status code 301).
  #
  # The `Moved Permanently` response indicates that links or records returning
  # this response should be updated to use the given URL. See [301 Moved
  # Permanently](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#301).
  #
  class HTTPMovedPermanently < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Found` responses (status code 302).
  #
  # The `Found` response indicates that the client should look at (browse to)
  # another URL. See [302
  # Found](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#302).
  #
  class HTTPFound < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `See Other` responses (status code 303).
  #
  # The response to the request can be found under another URI using the GET
  # method. See [303 See
  # Other](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#303).
  #
  class HTTPSeeOther < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Modified` responses (status code 304).
  #
  # Indicates that the resource has not been modified since the version specified
  # by the request headers. See [304 Not
  # Modified](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#304).
  #
  class HTTPNotModified < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Use Proxy` responses (status code 305).
  #
  # The requested resource is available only through a proxy, whose address is
  # provided in the response. See [305 Use
  # Proxy](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#305).
  #
  class HTTPUseProxy < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Temporary Redirect` responses (status code 307).
  #
  # The request should be repeated with another URI; however, future requests
  # should still use the original URI. See [307 Temporary
  # Redirect](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#307).
  #
  class HTTPTemporaryRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Permanent Redirect` responses (status code 308).
  #
  # This and all future requests should be directed to the given URI. See [308
  # Permanent
  # Redirect](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#308).
  #
  class HTTPPermanentRedirect < HTTPRedirection
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Bad Request` responses (status code 400).
  #
  # The server cannot or will not process the request due to an apparent client
  # error. See [400 Bad
  # Request](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#400).
  #
  class HTTPBadRequest < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unauthorized` responses (status code 401).
  #
  # Authentication is required, but either was not provided or failed. See [401
  # Unauthorized](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#401).
  #
  class HTTPUnauthorized < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Payment Required` responses (status code 402).
  #
  # Reserved for future use. See [402 Payment
  # Required](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#402).
  #
  class HTTPPaymentRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Forbidden` responses (status code 403).
  #
  # The request contained valid data and was understood by the server, but the
  # server is refusing action. See [403
  # Forbidden](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#403).
  #
  class HTTPForbidden < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Found` responses (status code 404).
  #
  # The requested resource could not be found but may be available in the future.
  # See [404 Not
  # Found](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#404).
  #
  class HTTPNotFound < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Method Not Allowed` responses (status code 405).
  #
  # The request method is not supported for the requested resource. See [405
  # Method Not
  # Allowed](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#405).
  #
  class HTTPMethodNotAllowed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Acceptable` responses (status code 406).
  #
  # The requested resource is capable of generating only content that not
  # acceptable according to the Accept headers sent in the request. See [406 Not
  # Acceptable](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#406).
  #
  class HTTPNotAcceptable < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Proxy Authentication Required` responses (status code
  # 407).
  #
  # The client must first authenticate itself with the proxy. See [407 Proxy
  # Authentication
  # Required](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#407).
  #
  class HTTPProxyAuthenticationRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Request Timeout` responses (status code 408).
  #
  # The server timed out waiting for the request. See [408 Request
  # Timeout](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#408).
  #
  class HTTPRequestTimeout < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Conflict` responses (status code 409).
  #
  # The request could not be processed because of conflict in the current state of
  # the resource. See [409
  # Conflict](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#409).
  #
  class HTTPConflict < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Gone` responses (status code 410).
  #
  # The resource requested was previously in use but is no longer available and
  # will not be available again. See [410
  # Gone](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#410).
  #
  class HTTPGone < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Length Required` responses (status code 411).
  #
  # The request did not specify the length of its content, which is required by
  # the requested resource. See [411 Length
  # Required](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#411).
  #
  class HTTPLengthRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Precondition Failed` responses (status code 412).
  #
  # The server does not meet one of the preconditions specified in the request
  # headers. See [412 Precondition
  # Failed](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#412).
  #
  class HTTPPreconditionFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Payload Too Large` responses (status code 413).
  #
  # The request is larger than the server is willing or able to process. See [413
  # Payload Too
  # Large](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#413).
  #
  class HTTPPayloadTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `URI Too Long` responses (status code 414).
  #
  # The URI provided was too long for the server to process. See [414 URI Too
  # Long](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#414).
  #
  class HTTPURITooLong < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unsupported Media Type` responses (status code 415).
  #
  # The request entity has a media type which the server or resource does not
  # support. See [415 Unsupported Media
  # Type](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#415).
  #
  class HTTPUnsupportedMediaType < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Range Not Satisfiable` responses (status code 416).
  #
  # The request entity has a media type which the server or resource does not
  # support. See [416 Range Not
  # Satisfiable](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#416).
  #
  class HTTPRangeNotSatisfiable < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Expectation Failed` responses (status code 417).
  #
  # The server cannot meet the requirements of the Expect request-header field.
  # See [417 Expectation
  # Failed](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#417).
  #
  class HTTPExpectationFailed < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Misdirected Request` responses (status code 421).
  #
  # The request was directed at a server that is not able to produce a response.
  # See [421 Misdirected
  # Request](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#421).
  #
  class HTTPMisdirectedRequest < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unprocessable Entity` responses (status code 422).
  #
  # The request was well-formed but had semantic errors. See [422 Unprocessable
  # Entity](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#422).
  #
  class HTTPUnprocessableEntity < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Locked (WebDAV)` responses (status code 423).
  #
  # The requested resource is locked. See [423 Locked
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#423).
  #
  class HTTPLocked < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Failed Dependency (WebDAV)` responses (status code 424).
  #
  # The request failed because it depended on another request and that request
  # failed. See [424 Failed Dependency
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#424).
  #
  class HTTPFailedDependency < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Upgrade Required` responses (status code 426).
  #
  # The client should switch to the protocol given in the Upgrade header field.
  # See [426 Upgrade
  # Required](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#426).
  #
  class HTTPUpgradeRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Precondition Required` responses (status code 428).
  #
  # The origin server requires the request to be conditional. See [428
  # Precondition
  # Required](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#428).
  #
  class HTTPPreconditionRequired < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Too Many Requests` responses (status code 429).
  #
  # The user has sent too many requests in a given amount of time. See [429 Too
  # Many Requests](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#429).
  #
  class HTTPTooManyRequests < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Request Header Fields Too Large` responses (status code
  # 431).
  #
  # An individual header field is too large, or all the header fields
  # collectively, are too large. See [431 Request Header Fields Too
  # Large](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#431).
  #
  class HTTPRequestHeaderFieldsTooLarge < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Unavailable For Legal Reasons` responses (status code
  # 451).
  #
  # A server operator has received a legal demand to deny access to a resource or
  # to a set of resources that includes the requested resource. See [451
  # Unavailable For Legal
  # Reasons](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#451).
  #
  class HTTPUnavailableForLegalReasons < HTTPClientError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Internal Server Error` responses (status code 500).
  #
  # An unexpected condition was encountered and no more specific message is
  # suitable. See [500 Internal Server
  # Error](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#500).
  #
  class HTTPInternalServerError < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Implemented` responses (status code 501).
  #
  # The server either does not recognize the request method, or it lacks the
  # ability to fulfil the request. See [501 Not
  # Implemented](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#501).
  #
  class HTTPNotImplemented < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Bad Gateway` responses (status code 502).
  #
  # The server was acting as a gateway or proxy and received an invalid response
  # from the upstream server. See [502 Bad
  # Gateway](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#502).
  #
  class HTTPBadGateway < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Service Unavailable` responses (status code 503).
  #
  # The server cannot handle the request (because it is overloaded or down for
  # maintenance). See [503 Service
  # Unavailable](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#503).
  #
  class HTTPServiceUnavailable < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Gateway Timeout` responses (status code 504).
  #
  # The server was acting as a gateway or proxy and did not receive a timely
  # response from the upstream server. See [504 Gateway
  # Timeout](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#504).
  #
  class HTTPGatewayTimeout < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `HTTP Version Not Supported` responses (status code 505).
  #
  # The server does not support the HTTP version used in the request. See [505
  # HTTP Version Not
  # Supported](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#505).
  #
  class HTTPVersionNotSupported < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Variant Also Negotiates` responses (status code 506).
  #
  # Transparent content negotiation for the request results in a circular
  # reference. See [506 Variant Also
  # Negotiates](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#506).
  #
  class HTTPVariantAlsoNegotiates < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Insufficient Storage (WebDAV)` responses (status code
  # 507).
  #
  # The server is unable to store the representation needed to complete the
  # request. See [507 Insufficient Storage
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#507).
  #
  class HTTPInsufficientStorage < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Loop Detected (WebDAV)` responses (status code 508).
  #
  # The server detected an infinite loop while processing the request. See [508
  # Loop Detected
  # (WebDAV)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#508).
  #
  class HTTPLoopDetected < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Not Extended` responses (status code 510).
  #
  # Further extensions to the request are required for the server to fulfill it.
  # See [510 Not
  # Extended](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#510).
  #
  class HTTPNotExtended < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/responses.rb -->
  # Response class for `Network Authentication Required` responses (status code
  # 511).
  #
  # The client needs to authenticate to gain network access. See [511 Network
  # Authentication
  # Required](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#511).
  #
  class HTTPNetworkAuthenticationRequired < HTTPServerError
    HAS_BODY: bool
  end

  # <!-- rdoc-file=lib/net/http/response.rb -->
  # This class is the base class for Net::HTTP request classes.
  #
  # ## About the Examples
  #
  # Examples here assume that `net/http` has been required (which also requires
  # `uri`):
  #
  #     require 'net/http'
  #
  # Many code examples here use these example websites:
  #
  # *   https://jsonplaceholder.typicode.com.
  # *   http://example.com.
  #
  #
  # Some examples also assume these variables:
  #
  #     uri = URI('https://jsonplaceholder.typicode.com')
  #     uri.freeze # Examples may not modify.
  #     hostname = uri.hostname # => "jsonplaceholder.typicode.com"
  #     port = uri.port         # => 443
  #
  # So that example requests may be written as:
  #
  #     Net::HTTP.get(uri)
  #     Net::HTTP.get(hostname, '/index.html')
  #     Net::HTTP.start(hostname) do |http|
  #       http.get('/todos/1')
  #       http.get('/todos/2')
  #     end
  #
  # An example that needs a modified URI first duplicates `uri`, then modifies the
  # duplicate:
  #
  #     _uri = uri.dup
  #     _uri.path = '/todos/1'
  #
  # ## Returned Responses
  #
  # Method Net::HTTP.get_response returns an instance of one of the subclasses of
  # Net::HTTPResponse:
  #
  #     Net::HTTP.get_response(uri)
  #     # => #<Net::HTTPOK 200 OK readbody=true>
  #     Net::HTTP.get_response(hostname, '/nosuch')
  #     # => #<Net::HTTPNotFound 404 Not Found readbody=true>
  #
  # As does method Net::HTTP#request:
  #
  #     req = Net::HTTP::Get.new(uri)
  #     Net::HTTP.start(hostname) do |http|
  #       http.request(req)
  #     end # => #<Net::HTTPOK 200 OK readbody=true>
  #
  # Class Net::HTTPResponse includes module Net::HTTPHeader, which provides access
  # to response header values via (among others):
  #
  # *   Hash-like method `[]`.
  # *   Specific reader methods, such as `content_type`.
  #
  #
  # Examples:
  #
  #     res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
  #     res['Content-Type']               # => "text/html; charset=UTF-8"
  #     res.content_type                  # => "text/html"
  #
  # ## Response Subclasses
  #
  # Class Net::HTTPResponse has a subclass for each [HTTP status
  # code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). You can look
  # up the response class for a given code:
  #
  #     Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
  #     Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
  #     Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
  #
  # And you can retrieve the status code for a response object:
  #
  #     Net::HTTP.get_response(uri).code                 # => "200"
  #     Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
  #
  # The response subclasses (indentation shows class hierarchy):
  #
  # *   Net::HTTPUnknownResponse (for unhandled HTTP extensions).
  #
  # *   Net::HTTPInformation:
  #
  #     *   Net::HTTPContinue (100)
  #     *   Net::HTTPSwitchProtocol (101)
  #     *   Net::HTTPProcessing (102)
  #     *   Net::HTTPEarlyHints (103)
  #
  #
  # *   Net::HTTPSuccess:
  #
  #     *   Net::HTTPOK (200)
  #     *   Net::HTTPCreated (201)
  #     *   Net::HTTPAccepted (202)
  #     *   Net::HTTPNonAuthoritativeInformation (203)
  #     *   Net::HTTPNoContent (204)
  #     *   Net::HTTPResetContent (205)
  #     *   Net::HTTPPartialContent (206)
  #     *   Net::HTTPMultiStatus (207)
  #     *   Net::HTTPAlreadyReported (208)
  #     *   Net::HTTPIMUsed (226)
  #
  #
  # *   Net::HTTPRedirection:
  #
  #     *   Net::HTTPMultipleChoices (300)
  #     *   Net::HTTPMovedPermanently (301)
  #     *   Net::HTTPFound (302)
  #     *   Net::HTTPSeeOther (303)
  #     *   Net::HTTPNotModified (304)
  #     *   Net::HTTPUseProxy (305)
  #     *   Net::HTTPTemporaryRedirect (307)
  #     *   Net::HTTPPermanentRedirect (308)
  #
  #
  # *   Net::HTTPClientError:
  #
  #     *   Net::HTTPBadRequest (400)
  #     *   Net::HTTPUnauthorized (401)
  #     *   Net::HTTPPaymentRequired (402)
  #     *   Net::HTTPForbidden (403)
  #     *   Net::HTTPNotFound (404)
  #     *   Net::HTTPMethodNotAllowed (405)
  #     *   Net::HTTPNotAcceptable (406)
  #     *   Net::HTTPProxyAuthenticationRequired (407)
  #     *   Net::HTTPRequestTimeOut (408)
  #     *   Net::HTTPConflict (409)
  #     *   Net::HTTPGone (410)
  #     *   Net::HTTPLengthRequired (411)
  #     *   Net::HTTPPreconditionFailed (412)
  #     *   Net::HTTPRequestEntityTooLarge (413)
  #     *   Net::HTTPRequestURITooLong (414)
  #     *   Net::HTTPUnsupportedMediaType (415)
  #     *   Net::HTTPRequestedRangeNotSatisfiable (416)
  #     *   Net::HTTPExpectationFailed (417)
  #     *   Net::HTTPMisdirectedRequest (421)
  #     *   Net::HTTPUnprocessableEntity (422)
  #     *   Net::HTTPLocked (423)
  #     *   Net::HTTPFailedDependency (424)
  #     *   Net::HTTPUpgradeRequired (426)
  #     *   Net::HTTPPreconditionRequired (428)
  #     *   Net::HTTPTooManyRequests (429)
  #     *   Net::HTTPRequestHeaderFieldsTooLarge (431)
  #     *   Net::HTTPUnavailableForLegalReasons (451)
  #
  #
  # *   Net::HTTPServerError:
  #
  #     *   Net::HTTPInternalServerError (500)
  #     *   Net::HTTPNotImplemented (501)
  #     *   Net::HTTPBadGateway (502)
  #     *   Net::HTTPServiceUnavailable (503)
  #     *   Net::HTTPGatewayTimeOut (504)
  #     *   Net::HTTPVersionNotSupported (505)
  #     *   Net::HTTPVariantAlsoNegotiates (506)
  #     *   Net::HTTPInsufficientStorage (507)
  #     *   Net::HTTPLoopDetected (508)
  #     *   Net::HTTPNotExtended (510)
  #     *   Net::HTTPNetworkAuthenticationRequired (511)
  #
  #
  #
  # There is also the Net::HTTPBadResponse exception which is raised when there is
  # a protocol error.
  #
  class HTTPResponse
    CODE_CLASS_TO_OBJ: Hash[untyped, untyped]

    CODE_TO_OBJ: Hash[untyped, untyped]
  end

  HTTP::STATUS_CODES: Hash[Integer, String]

  # <!-- rdoc-file=lib/net/http/exceptions.rb -->
  # Net::HTTP exception class. You cannot use Net::HTTPExceptions directly;
  # instead, you must use its subclasses.
  #
  module HTTPExceptions
    def initialize: (untyped msg, untyped res) -> untyped

    attr_reader response: untyped

    alias data response
  end

  class HTTPError < ProtocolError
    include Net::HTTPExceptions
  end

  class HTTPRetriableError < ProtoRetriableError
    include Net::HTTPExceptions
  end

  class HTTPServerException < ProtoServerError
    # We cannot use the name "HTTPServerError", it is the name of the response.
    include Net::HTTPExceptions
  end

  class HTTPFatalError < ProtoFatalError
    include Net::HTTPExceptions
  end
end
